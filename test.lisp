(< 5 4)
(< 4 5)
(< 4.5 5)
(< 4 4.5)
(< (+ 4 2) (+ 4 5))
(< (+ (- 5 4) (+ 2 (+ 1 1))) 7)

(> 5 4)
(> 4 5)
(> 4.5 5)
(> 4 4.5)
(> (+ 4 2) (+ 4 5))

(<= 5 4)
(<= 4 5)
(<= 4.5 5)
(<= 4 4.5)
(<= (+ 4 2) (+ 4 5))

(>= 5 4)
(>= 4 5)
(>= 4.5 5)
(>= 4 4.5)
(>= (+ 4 2) (+ 4 5))

(quote 3)
(quote nil)
(quote (+ 3 4))
(quote (list 2 3 4 5))
(quote (+ 3))

(eval (quote nil))
(eval (quote 3))
(eval (quote (+ 3 4)))
(eval (quote (+ (- 6 5) (+ 3 4))))

(and)
(and 3 4 5)
(and 1 2)
(and 1)
(and nil nil nil nil)
(and 3 4 5 nil)
(and (+ 3 2) (+ 3 4))
(and (+ 3 2) (< 3 1))


(or)
(or 1)
(or nil)
(or nil nil 3 4 5)
(or 3 nil nil nil)
(or (< 3 1) (< 4 1) (< 3 5))
(or (< 3 1) (< 4 1) (+ 3 5))

(not 1)
(not nil)
(not (< 3 4))
(not (> 3 4))

(list (+ 5 2))
(list 3 2 1)
(list 3 2 nil)
(list nil)
(list)
(list (+ 3 2) (+ 3 (- 5 2)) (< 4 5))

(cond (T 1))
(cond (nil 3) (T 6))
(cond (nil 4) (T 7))
(cond (nil 5) (T 9))
(cond (nil 4) (nil 3) (nil 3) (T 1) (nil 65))
(cond (nil 5) ((< 4 1) 6) (T 11))
(cond ((> 2 1) 6) ((< 4 1) 6) (T 9))
(cond ((< 10 2) 8) ((> 4 2) 8) (nil 10))

(cons nil nil)
(cons nil nil)
(cons nil 5)
(cons 5 (list 4 3 2))

( SETQ A 29)
( SETQ B (+ A 13))
B
((lambda () (+ 41 (+ 0 1))))
((lambda (X) (* (+ 1 1) X)) 21)
((lambda (X Y) (+ X (+ Y 0))) 40 2)
(setq LISTDERIVEDSAFE (lambda (Dist Dur Exh) 
	(or 
		(and (>= Dist 13) (<= Dur 30) (<= Exh 30)) 
		(and (>= Dist 6) (<= Dur 30) (<= Exh 10))
		(and (>= Dist 27) (<= Dur 30) (<= Exh 50))
		(and (>= Dist 13) (<= Dur 15) (<= Exh 50))
		(and (>= Dist 13) (<= Dur 15) (<= Exh 50))
		(and (>= Dist 13) (<= Dur 120) (<= Exh 10))
		(and (>= Dist 27) (<= Dur 120) (<= Exh 30))
		(and (>= Dist 6) (<= Dur 15) (<= Exh 30))
	)
))
(setq x 5)
(setq timesGenerator
    (lambda (x)
  	(function
                (lambda (y) (* x y))
            )
    )
)
(setq twice (funcall timesGenerator 2))
(setq product3 (lambda (x y z) (* x (* y z))))
(setq product2 (curry product3 1))
(setq identity (curry product2 1))
(setq isList ( lambda (X) 
	(cond
		   ((eq X nil) nil)
		   (T (funcall isListHelper X))
	)
))
(setq isListHelper ( lambda (X) 
	(cond
		   ((atom X) (eq X nil))
		   (T (funcall isListHelper (cdr X)))
	)
))
(setq toStringAsSExpression 
	  (lambda (X)
			(cond 
				((atom X) (write-to-string X))
				(T (concatenate (quote String) "(" (funcall toString (car X)) " . " (funcall toString (cdr X)) ")"))
			)
		)
)
(setq toStringAsList
	  (lambda (X) (concatenate (quote String) "(" (funcall toStringAsListHelper X 1) ")"))
)
(setq toStringAsListHelper (lambda (X M)
	(cond ((atom (cdr X)) (concatenate (quote String) (cond ((eq M 1) "") (T " ")) (funcall toString (car X))))
			(T (concatenate (quote String) (cond ((eq M 1) "") (T " ")) (funcall toString (car X)) (funcall toStringAsListHelper (cdr x) 0)))
		  )
(setq toString (lambda (X) (cond ((funcall isList X) (funcall toStringAsList X)) (T (funcall toStringAsSExpression X)))))
(setq numAtoms
	(lambda(X)
		(cond
			((atom X) 1)
			(T (+ (funcall numAtoms (car X)) (funcall numAtoms (cdr X))))
		)
	)
)
(setq filterList
	  (lambda (Handler L)
		(cond
		  ((eq L nil) nil)
		  (T (cons
			   (funcall Handler (car L))
			   (funcall filterList Handler (cdr L))
			   )
			 )
		  )
		)
	  )
(setq f1Handler (lambda (X) (atom X)))
(setq f1Clone (curry filterList f1Handler))
(setq f2Handler (lambda (X) (not X)))
(setq f2Clone (curry filterList f2Handler))
